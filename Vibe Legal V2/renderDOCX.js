const { Document, Packer, Paragraph, TextRun, HeadingLevel, AlignmentType } = require('docx');
const fs = require('fs');

class DOCXRenderer {
  constructor() {}

  parseMarkdownToDocx(markdown) {
    const lines = markdown.split('\n');
    const paragraphs = [];

    lines.forEach(line => {
      if (line.trim() === '') {
        return; // Skip empty lines
      }

      if (line.startsWith('# ')) {
        // Main title
        paragraphs.push(
          new Paragraph({
            text: line.substring(2),
            heading: HeadingLevel.TITLE,
            alignment: AlignmentType.CENTER,
            spacing: { after: 400 }
          })
        );
      } else if (line.startsWith('## ')) {
        // Section heading
        paragraphs.push(
          new Paragraph({
            text: line.substring(3),
            heading: HeadingLevel.HEADING_1,
            spacing: { before: 400, after: 200 }
          })
        );
      } else if (line.startsWith('### ')) {
        // Subsection heading
        paragraphs.push(
          new Paragraph({
            text: line.substring(4),
            heading: HeadingLevel.HEADING_2,
            spacing: { before: 200, after: 100 }
          })
        );
      } else {
        // Regular paragraph
        const textRuns = this.parseTextFormatting(line);
        paragraphs.push(
          new Paragraph({
            children: textRuns,
            spacing: { after: 200 },
            alignment: AlignmentType.JUSTIFIED
          })
        );
      }
    });

    // Add disclaimer
    paragraphs.push(
      new Paragraph({
        children: [
          new TextRun({
            text: 'LEGAL DISCLAIMER: This document is generated by AI and should be reviewed by a qualified attorney before use. This does not constitute legal advice.',
            bold: true,
            size: 20
          })
        ],
        spacing: { before: 800, after: 200 },
        alignment: AlignmentType.CENTER
      })
    );

    return paragraphs;
  }

  parseTextFormatting(text) {
    const textRuns = [];
    let currentText = text;
    
    // Simple bold formatting
    const boldRegex = /\*\*(.+?)\*\*/g;
    let lastIndex = 0;
    let match;

    while ((match = boldRegex.exec(text)) !== null) {
      // Add text before bold
      if (match.index > lastIndex) {
        textRuns.push(new TextRun(text.substring(lastIndex, match.index)));
      }
      
      // Add bold text
      textRuns.push(new TextRun({
        text: match[1],
        bold: true
      }));
      
      lastIndex = boldRegex.lastIndex;
    }

    // Add remaining text
    if (lastIndex < text.length) {
      textRuns.push(new TextRun(text.substring(lastIndex)));
    }

    return textRuns.length > 0 ? textRuns : [new TextRun(text)];
  }

  async renderToDOCX(contractText, title = 'Contract') {
    const paragraphs = this.parseMarkdownToDocx(contractText);

    const doc = new Document({
      sections: [{
        properties: {},
        children: paragraphs
      }]
    });

    return await Packer.toBuffer(doc);
  }

  async renderToFile(contractText, outputPath, title = 'Contract') {
    const docxBuffer = await this.renderToDOCX(contractText, title);
    fs.writeFileSync(outputPath, docxBuffer);
    return outputPath;
  }
}

module.exports = DOCXRenderer;

